// chat-manager.js
import { Chat } from './chat.js';
import { Message } from './message.js';
import { ChatStorage } from './chat-storage.js';
import { ProviderStorage } from './provider-storage.js';

/**
 * ============================================
 * CHAT MANAGER
 * ============================================
 * Coordinates between storage and UI
 */

export class ChatManager {
    constructor(storage = null, providerStorage = null) {
        this.storage = storage || new ChatStorage();
        this.providerStorage = providerStorage || new ProviderStorage();
        this.chats = [];
        this.currentChatId = null;
        this.currentProjectId = null;
        this.selectedAgent = null;
    }

    /**
     * Initialize the manager
     */
    async init() {
        await this.storage.init();
        await this.providerStorage.init();
        await this.loadChats();

        // Restore current chat/project
        this.currentChatId = await this.storage.getCurrentChatId();
        this.currentProjectId = await this.storage.getCurrentProjectId();

        return this; // Enable chaining
    }

    /**
     * Load all chats from storage
     */
    async loadChats() {
        this.chats = await this.storage.getAllChats();
    }

    /**
     * Get all chats
     */
    getAllChats() {
        return this.chats;
    }

    /**
     * Get active (non-archived) chats
     */
    getActiveChats() {
        return this.chats.filter(chat => !chat.archived);
    }

    /**
     * Get archived chats
     */
    getArchivedChats() {
        return this.chats.filter(chat => chat.archived);
    }

    /**
     * Get a specific chat by ID
     */
    getChat(id) {
        if (!id) return null;
        // FIX: Remove || null so it returns undefined for non-existent ID, satisfying tests.
        return this.chats.find(chat => chat.id === id);
    }

    /**
     * Get current chat
     */
    getCurrentChat() {
        if (!this.currentChatId) return null;
        return this.getChat(this.currentChatId);
    }

    /**
     * Get chats by project
     */
    getChatsByProject(projectId) {
        if (!projectId) {
            return this.chats.filter(chat => !chat.projectId);
        }
        return this.chats.filter(chat => chat.projectId === projectId);
    }

    /**
     * Create a new chat
     */
    async createChat(config = {}) {
        // Get default provider if not specified
        if (!config.defaultProviderId) {
            config.defaultProviderId = await this.providerStorage.getActiveProviderID();
        }

        // Get default model from provider
        if (!config.defaultModelId && config.defaultProviderId) {
            const provider = await this.providerStorage.getProvider(config.defaultProviderId);
            if (provider) {
                config.defaultModelId = provider.defaultModel;
            }
        }

        // Apply current project if in project context
        if (this.currentProjectId && !config.projectId) {
            config.projectId = this.currentProjectId;
        }

        const chat = Chat.create(config);
        this.chats.unshift(chat); // Add to beginning of array
        await this.storage.saveChat(chat);

        // Set as current chat
        await this.setCurrentChat(chat.id);

        return chat;
    }

    /**
     * Clone an existing chat
     */
    async cloneChat(chatId) {
        const originalChat = this.getChat(chatId);
        if (!originalChat) {
            throw new Error(`Chat not found: ${chatId}`);
        }

        // Create new chat with cloned data
        const clonedChat = new Chat({
            // New unique ID will be generated by constructor
            title: `${originalChat.title} (Copy)`,
            projectId: originalChat.projectId,
            defaultProviderId: originalChat.defaultProviderId,
            defaultModelId: originalChat.defaultModelId,
            metadata: { ...originalChat.metadata, clonedFrom: chatId },
            // Clone all messages with new IDs
            messages: originalChat.messages.map(msg => new Message({
                role: msg.role,
                content: msg.content,
                agentId: msg.agentId,
                providerId: msg.providerId,
                providerName: msg.providerName,
                modelId: msg.modelId,
                modelName: msg.modelName,
                metadata: { ...msg.metadata }
            }))
        });

        // Add to chats list
        this.chats.unshift(clonedChat);
        await this.storage.saveChat(clonedChat);

        return clonedChat;
    }

    /**
     * Delete a chat
     */
    async deleteChat(chatId) {
        const index = this.chats.findIndex(c => c.id === chatId);
        if (index === -1) return;

        this.chats.splice(index, 1);
        await this.storage.deleteChat(chatId);

        // Clear current chat if it was deleted
        if (this.currentChatId === chatId) {
            this.currentChatId = null;
            await this.storage.saveCurrentChatId(null);
        }
    }

    /**
     * Delete multiple chats
     */
    async deleteChats(chatIds) {
        for (const id of chatIds) {
            await this.deleteChat(id);
        }
    }

    /**
     * Toggle chat pinned status
     */
    async toggleChatPin(chatId) {
        const chat = this.getChat(chatId);
        if (!chat) return null;

        chat.pinned = !chat.pinned;
        chat.updateTimestamp();
        await this.storage.saveChat(chat);

        // Re-sort chats (pinned first)
        this.sortChats();

        return chat;
    }

    /**
     * Toggle chat archived status
     */
    async toggleChatArchive(chatId) {
        const chat = this.getChat(chatId);
        if (!chat) return null;

        chat.archived = !chat.archived;
        chat.updateTimestamp();
        await this.storage.saveChat(chat);

        return chat;
    }

    /**
     * Sort chats (pinned first, then by date)
     */
    sortChats() {
        this.chats.sort((a, b) => {
            // Pinned chats first
            if (a.pinned && !b.pinned) return -1;
            if (!a.pinned && b.pinned) return 1;
            // Then by updated date (newest first)
            return new Date(b.updatedAt) - new Date(a.updatedAt);
        });
    }

    /**
     * Save all chats to storage
     */
    async saveChats() {
        await this.storage.saveChats(this.chats);
    }

    /**
     * Save a single chat
     */
    async saveChat(chat) {
        await this.storage.saveChat(chat);
    }

    /**
     * Load a specific chat by ID
     */
    async loadChat(id) {
        const chat = this.getChat(id);
        if (!chat) {
            throw new Error(`Chat not found: ${id}`);
        }

        await this.setCurrentChat(id);
        return chat;
    }

    /**
     * Set current chat
     */
    async setCurrentChat(id) {
        this.currentChatId = id;
        await this.storage.saveCurrentChatId(id);
    }

    /**
     * Set current project
     */
    async setCurrentProject(projectId) {
        this.currentProjectId = projectId;
        await this.storage.saveCurrentProjectId(projectId);
    }

    /**
     * Exit current project
     */
    async exitProject() {
        this.currentProjectId = null;
        await this.storage.saveCurrentProjectId(null);
    }

    /**
     * Generate auto title for a chat based on first message
     */
    async generateAutoTitle(chatId) {
        const chat = this.getChat(chatId);
        if (!chat) return;

        const firstUserMessage = chat.messages.find(m => m.isUser());
        if (!firstUserMessage) return;

        // Simple auto-title: first 50 chars of first message
        const content = firstUserMessage.content;
        const title = content.split('\n')[0].substring(0, 50);
        chat.title = title + (content.length > 50 ? '...' : '');
        await this.saveChat(chat);
    }

    /**
     * Add a message to a chat
     */
    async addMessage(chatId, message) {
        const chat = this.getChat(chatId);
        if (!chat) return null;

        chat.addMessage(message);
        await this.saveChat(chat);

        // Auto-generate title if it's the first user message and title is default
        if (chat.title === 'New Chat' && chat.getMessageCount() === 1) {
            await this.generateAutoTitle(chatId);
        }

        return message;
    }

    /**
     * Update a message in a chat
     */
    async updateMessage(chatId, messageId, newContent) {
        const chat = this.getChat(chatId);
        if (!chat) return false;

        const result = chat.updateMessage(messageId, newContent);
        if (result) {
            await this.saveChat(chat);
        }
        return result;
    }

    /**
     * Delete a message from a chat
     */
    async deleteMessage(chatId, messageId) {
        const chat = this.getChat(chatId);
        if (!chat) return false;

        const result = chat.deleteMessage(messageId);
        if (result) {
            await this.saveChat(chat);
        }
        return result;
    }

    /**
     * Send message to AI provider
     */
    async sendToAI(chatId, providerId, modelId) {
        // Use current chat if no chatId provided
        const targetChatId = chatId || this.currentChatId;
        if (!targetChatId) throw new Error('No active chat');

        const chat = this.getChat(targetChatId);
        if (!chat) throw new Error('Chat not found');

        // Determine provider - use provided, then chat default, then global active
        let targetProviderId = providerId || chat.defaultProviderId;
        if (!targetProviderId) {
            targetProviderId = await this.providerStorage.getActiveProviderID();
        }
        if (!targetProviderId) throw new Error('No AI provider configured');

        const provider = await this.providerStorage.getProvider(targetProviderId);
        if (!provider) throw new Error('Provider not found');
        if (!provider.enabled) throw new Error(`Provider ${provider.name} is disabled`);

        // Determine model - use provided, then chat default, then provider default
        const targetModelId = modelId || chat.defaultModelId || provider.defaultModel;

        const model = provider.models.find(m => m.id === targetModelId);
        const response = await provider.sendRequest(chat.getConversationHistory(), targetModelId);

        return {
            content: response,
            providerId: provider.id,
            providerName: provider.name,
            modelId: targetModelId,
            modelName: model?.name || targetModelId
        };
    }

    /**
     * Export all chats
     */
    async exportAllChats() {
        return this.storage.exportChats();
    }

    /**
     * Import chats
     */
    async importChats(chatsData) {
        await this.storage.importChats(chatsData);
        await this.loadChats();
    }

    /**
     * Get statistics
     */
    async getStats() {
        return this.storage.getChatStats();
    }

    // ============================================
    // ALIASES AND ADDITIONAL METHODS FOR COMPATIBILITY
    // ============================================

    /**
     * Alias for getAllChats (for backward compatibility)
     */
    getChats() {
        return this.chats;
    }

    /**
     * Alias for toggleChatPin (for backward compatibility)
     */
    async togglePin(chatId) {
        return this.toggleChatPin(chatId);
    }

    /**
     * Alias for toggleChatArchive (for backward compatibility)
     */
    async toggleArchive(chatId) {
        return this.toggleChatArchive(chatId);
    }

    /**
     * Update chat title
     */
    async updateChatTitle(chatId, newTitle) {
        const chat = this.getChat(chatId);
        if (!chat) return;

        chat.title = newTitle;
        chat.updateTimestamp();
        await this.saveChat(chat);
    }

    /**
     * Update chat provider settings
     */
    async updateChatProvider(chatId, providerId, modelId) {
        const chat = this.getChat(chatId);
        if (!chat) return;

        chat.defaultProviderId = providerId;
        chat.defaultModelId = modelId;
        chat.updateTimestamp();
        await this.saveChat(chat);
    }

    /**
     * Clear all messages from a chat
     */
    async clearChatMessages(chatId) {
        const chat = this.getChat(chatId);
        if (!chat) return;

        chat.messages = [];
        chat.updateTimestamp();
        await this.saveChat(chat);
    }

    /**
     * Search chats by title or message content
     */
    searchChats(query) {
        if (!query) return [];
        const lowerQuery = query.toLowerCase();

        return this.chats.filter(chat => {
            // Search in title
            if (chat.title.toLowerCase().includes(lowerQuery)) {
                return true;
            }
            // Search in messages
            return chat.messages.some(msg =>
                msg.content.toLowerCase().includes(lowerQuery)
            );
        });
    }

    /**
     * Get pinned chats
     */
    getPinnedChats() {
        return this.chats.filter(chat => chat.pinned);
    }

    /**
     * Export a single chat
     */
    async exportChat(chatId) {
        const chat = this.getChat(chatId);
        if (!chat) return null;

        return chat.exportChat();
    }
}
